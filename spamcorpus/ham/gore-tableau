tab05-gore-nguyen.dviA Tableau Calculus with Automaton-Labelled
Formulae for Regular Grammar Logics
Rajeev GorÂ´e1 and Linh Anh Nguyen2
1 The Australian National University and NICTA
Canberra ACT 0200, Australia
Rajeev.Gore@anu.edu.au
2 Institute of Informatics, University of Warsaw
ul. Banacha 2, 02-097 Warsaw, Poland
nguyen@mimuw.edu.pl
Abstract. We present a sound and complete tableau calculus for theclass of regular grammar logics. Our tableau rules use a special featurecalled automaton-labelled formulae, which are similar to formulae of au-tomaton propositional dynamic logic. Our calculus is cut-free and hasthe analytic superformula property so it gives a decision procedure. Weshow that the known EXPTIME upper bound for regular grammar log-ics can be obtained using our tableau calculus. We also give an eï¬€ectiveCraig interpolation lemma for regular grammar logics using our calculus.
1
Introduction
Multimodal logics (and their description logic cousins) are useful in many ar-eas of computer science: for example, multimodal logics are used in knowledgerepresentation by interpreting [i]Ï• as â€œagent i knows/believes that Ï• is trueâ€[7, 15, 1]. Grammar logics are normal multimodal logics characterised by â€œinclu-sionâ€ axioms like [t1] . . . [th]Ï• âŠƒ [s1] . . . [sk]Ï•, where [ti] and [sj] are modalitiesindexed by members ti and sj from some ï¬xed set of indices. Thus [1][2]Ï• â†’ [1]Ï•captures â€œif agent one knows that agent two knows Ï•, then agent one knows Ï•â€.
Inclusion axioms correspond in a strict sense to grammar rules of the form
t1t2 . . . th â†’ s1s2 . . . sk when the index set is treated as a set of atomic words andjuxtaposition is treated as word composition. Various reï¬nements ask whetherthe corresponding grammar is left or right linear, or whether the language gen-erated by the corresponding grammar is regular, context-free etc.
Grammar logics were introduced by FariËœ
nas del Cerro and Penttonen in [8]
and have been studied widely [3, 4, 20, 11, 5]. Baldoni et al. [3] gave a preï¬xedtableau calculus for grammar logics and used it to show that the general satisï¬a-bility problem of right linear grammar logics is decidable and the general satisï¬a-bility problem of context-free grammar logics is undecidable. But the techniquesof Baldoni et al. cannot be easily extended to regular grammar logics.
While trying to understand why the decidability proof by Baldoni et al.
[3, 2] cannot be naturally extended to left linear grammars, Demri [4] observedthat although right linear grammars generate the same class of languages asleft linear grammars, this correspondence is not useful at the level of regulargrammar logics. By using a transformation into the satisï¬ability problem forpropositional dynamic logic (PDL), Demri was able to prove that the generalsatisï¬ability problem of regular grammar logics is EXPTIME-complete and thatthe general satisï¬ability problem of linear grammar logics is undecidable. In [5],Demri and de Nivelle gave a translation of the satisï¬ability problem for grammarlogics with converse into the two-variable guarded fragment GF2 of ï¬rst-orderlogic, and showed that the general satisï¬ability problem for regular grammarlogics with converse is in EXPTIME. The relationship between grammar logicsand description logics was considered, among others, in [11, 20].
Thus, various methods have been required to obtain complexity results and
decision procedures for regular grammar logics. We show that it is possible to givea (non-preï¬xed) tableau calculus which is a decision procedure for the whole classof regular grammar logics, and which also gives an estimate of the complexity ofthese logics. Eï¬ƒcient tableaux for propositional multimodal (description) logicsare highly competitive with translation methods, so it is not at all obvious thatthe translation into GF2 from [5] is the best method for deciding these logics.
The naive way to encode inclusion axioms in a non-preï¬xed tableau calculus is
to add a rule like ([t]) shown below at left. But such rules cannot lead to a generaldecision procedure because there are well-known examples like transitivity [t]Ï• âŠƒ[t][t]Ï•, whose analogous rule is shown below at right, which immediately causean inï¬nite branch by adding [t][t]Ï•, and then [t][t][t]Ï•, and so on:
X; [t]Ï•
X; [t]Ï•
([t])
(4t)
X; [t]Ï•; [s1][s2] . . . [sk]Ï•
X; [t]Ï•; [t][t]Ï•
Our calculus uses a special feature called automaton-labelled formulae, which
are similar to formulae of APDL [10]. Informally, whenever a formula [t]Ï• is trueat a tableau node w, we add an automaton labelled formula that tracks themodal transitions from w. If a sequence of transitions leads to a tableau node u,and this sequence corresponds to a word s1s2 . . . sk recognised by the automatonlabelled formula, then we add the formula Ï• to u. This captures the eï¬€ect of therule ([t]) above left in a tractable manner since the inï¬‚uence of [t]Ï• being true atw can be computed directly from the content of the automaton labelled formulaein node u. Our tableau calculus is sound, complete, cut-free and has the analyticsuperformula property, so it is a decision procedure. As usual for tableau calculi,it allows eï¬ƒcient implementation and good complexity estimation.
In Section 2, we deï¬ne regular grammar logics and automaton-labelled for-
mulae. In Section 3, we present our tableau calculus for regular grammar logics,and prove it sound. In Section 4, we prove it complete. In Section 5, we provethat the general satisï¬ability problem of regular grammar logics is in EXPTIMEby using our tableau rules in a systematic way. In Section 6, we use our calculusto prove eï¬€ective Craig interpolation for regular grammar logics. Further workand concluding remarks are in Section 7. The Appendix contains an example.
Acknowledgements: We are grateful to Pietro Abate, StÂ´ephane Demri, Mar-cus Kracht and an anonymous reviewer for their helpful comments and pointers.
22
Preliminaries
2.1
Deï¬nitions for Multimodal Logics
Our modal language is built from two disjoint sets: MOD is a ï¬nite set ofmodal indices and PROP is a set of primitive propositions. We use p and qfor elements of PROP and use t and s for elements of MOD. Formulae of ourprimitive language are recursively deï¬ned using the BNF grammar below:
Ï• ::= p | Â¬Ï• | Ï• âˆ§ Ï• | Ï• âˆ¨ Ï• | Ï• âŠƒ Ï• | [t]Ï• | t Ï•
A Kripke frame is a tuple W, Ï„, {Rt | t âˆˆ MOD} , where W is a nonempty
set of possible worlds, Ï„ âˆˆ W is the current world, and each Rt is a binaryrelation on W , called the accessibility relation for [t] and t . If Rt(w, u) holdsthen we say that the world u is accessible from the world w via Rt.
A Kripke model is a tuple W, Ï„, {Rt | t âˆˆ MOD}, h , where W, Ï„, {Rt | t âˆˆ
MOD} is a Kripke frame and h is a function mapping worlds to sets of primitivepropositions. For w âˆˆ W , the set of primitive propositions â€œtrueâ€ at w is h(w).
A model graph is a tuple W, Ï„, {Rt | t âˆˆ MOD}, H , where W, Ï„, {Rt | t âˆˆ
MOD} is a Kripke frame and H is a function mapping worlds to formula sets.We sometimes treat model graphs as models with H restricted to PROP.
Given a Kripke model M = W, Ï„, {Rt | t âˆˆ MOD}, h and a world w âˆˆ W ,
the satisfaction relation |= is deï¬ned as usual for the classical connectives withtwo extra clauses for the modalities as below:
M, w |= [t]Ï•
iï¬€
âˆ€v âˆˆ W.Rt(w, v) implies M, v |= Ï•
M, w |= t Ï•
iï¬€
âˆƒv âˆˆ W.Rt(w, v) and M, v |= Ï•.
We say that Ï• is satisï¬ed at w in M if M, w |= Ï•. We say that Ï• is satisï¬ed
in M and call M a model of Ï• if M, Ï„ |= Ï•.
If we consider only Kripke models, with no restrictions on Rt, we obtain a
normal multimodal logic with a standard Hilbert-style axiomatisation Kn.
Note: We now assume that formulae are in negation normal form, where âŠƒ is
translated away and Â¬ occurs only directly before primitive propositions. Everyformula Ï• has a logically equivalent formula Ï• which is in negation normal form.
2.2
Regular Grammar Logics
Recall that a ï¬nite automaton A is a tuple Î£, Q, I, Î´, F , where Î£ is the alphabet(for our case, Î£ = MOD), Q is a ï¬nite set of states, I âŠ† Q is the set of initialstates, Î´ âŠ† QÃ—Î£ Ã—Q is the transition relation, and F âŠ† Q is the set of acceptingstates. A run of A on a word s1 . . . sk is a ï¬nite sequence of states q0, q1, . . . , qksuch that q0 âˆˆ I and Î´(qiâˆ’1, si, qi) holds for every 1 â‰¤ i â‰¤ k. It is an acceptingrun if qk âˆˆ F . We say that A accepts word w if there exists an accepting run ofA on w. The set of all words accepted/recognised by A is denoted by L(A).
Given two binary relations R1 and R2 over W , their relational composition
R1 â—¦ R2 = {(x, y) | âˆƒy âˆˆ W.R1(x, y) &amp; R2(y, z)} is also a binary relation over W .
3A grammar logic is a multimodal logic extending Kn with â€œinclusion axiomsâ€
of the form [t1] . . . [th]Ï• âŠƒ [s1] . . . [sk]Ï•, where {t1, . . . th, s1, . . . sk} âŠ† MOD.Each inclusion axiom corresponds to the restriction Rs â—¦. . .â—¦R
âŠ† R â—¦. . .â—¦R
1
sk
t1
th
on accessibility relations where the corresponding side stands for the identityrelation if k = 0 or h = 0. For a grammar logic L, the L-frame restrictions arethe set of all such corresponding restrictions. A Kripke model is an L-model if itsframe satisï¬es all L-frame restrictions. A formula Ï• is L-satisï¬able if there existsan L-model satisfying it. A formula Ï• is L-valid if it is satisï¬ed in all L-models.
An inclusion axiom [t1] . . . [th]Ï• âŠƒ [s1] . . . [sk]Ï• can also be seen as the gram-
mar rule t1 . . . th â†’ s1 . . . sk where the corresponding side stands for the emptyword if k = 0 or h = 0. Thus the inclusion axioms of a grammar logic L capturea grammar G(L). Here we do not distinguish terminal symbols and nonterminalsymbols. G(L) is context-free if its rules are of the form t â†’ s1 . . . sk, and is reg-ular if it is context-free and for every t âˆˆ MOD there exists a ï¬nite automatonAt that recognises the words derivable from t using G(L).
A regular grammar logic L is a grammar logic whose inclusion axioms cor-
respond to grammar rules that collectively capture a regular grammar G(L). Aregular language is traditionally speciï¬ed either by a regular expression or bya left/right linear grammar or by a ï¬nite automaton. The ï¬rst two forms canbe transformed in PTIME to an equivalent ï¬nite automaton that is at mostpolynomially larger. But there is no syntactic way to specify the class of regular(context-free) grammars, and checking whether a context-free grammar gener-ates a regular language is undecidable (see, e.g., [14]). Hence, we cannot computethese automata if we are given an arbitrary regular grammar logic. We thereforeassume that for each t âˆˆ MOD we are given an automaton At recognising thewords derivable from t using G(L). These are the automata specifying L.
Lemma 1. Let L be a regular grammar logic and let {At | t âˆˆ MOD} be theautomata specifying L. Then the following conditions are equivalent:
(i) the word s1 . . . sk is accepted by At(ii) the formula [t]Ï• âŠƒ [s1] . . . [sk]Ï• is L-valid(iii) the inclusion Rs â—¦. . .â—¦R
âŠ† R
1
sk
t is a consequence of the L-frame restrictions.
Proof. The equivalence (ii) â‡” (iii) is well-known from correspondence theory[19]. The implication (i) â‡’ (ii) follows by induction on the length of the deriva-tion of s1 . . . sk from t by the grammar G(L), using substitution, the K-axiom[t](Ï• âŠƒ Ïˆ) âŠƒ ([t]Ï• âŠƒ [t]Ïˆ) and the modal necessitation rule Ï•/[t]Ï•. The im-plication (iii) â‡’ (i) follows by induction on the length of the derivation ofRs â—¦ . . . â—¦ R
âŠ† R
1
sk
t from the L-frame restrictions. See also [3, 4] for details.
Example 1. Let MOD = {1, . . . , m} for a ï¬xed m. Consider the grammar logicwith the inclusion axioms [i]Ï• âŠƒ [j][i]Ï• for any i, j âˆˆ MOD and [i]Ï• âŠƒ [j]Ï• ifi &gt; j. This is a regular grammar logic because the set of words derivable from iusing the corresponding grammar is {1, . . . , m}âˆ—.{1, . . . , i}. This set is recognisedby the automaton Ai = MOD, {p, q}, {p}, Î´i, {q} with Î´i = {(p, j, p) | 1 â‰¤ j â‰¤m} âˆª {(p, j, q) | 1 â‰¤ j â‰¤ i}. Note that the corresponding grammar is not â€œlinearâ€in that at most one symbol in the right hand side of a rule can be nonterminal.
42.3
Automaton-Labelled Formulae
If A is a ï¬nite automaton, Q is a subset of the states of A, and Ï• is a formulain the primitive language then (A, Q) : Ï• is an automaton-labelled formula.
Fix a regular grammar logic L and let {At = MOD, Qt, It, Î´t, Ft | t âˆˆ
MOD} be the automata specifying L. Let Î´t(Q, s) = {q | âˆƒq âˆˆ Q.(q, s, q ) âˆˆ Î´t}be the states which can be reached from Q via an s-transition using At. Theintuitions of automaton labelled formulae are as follows:
Tagging: A formula of the form [t]Ï• in a world u is represented by (At, It) : Ï•.Tracking: If (At, Q) : Ï• occurs at u and R(u, v) holds then we add the formula
(At, Î´t(Q, s)) : Ï• to v. In particular, if (At, It) : Ï• appears in world u andRs(u, v) holds then we add (At, Î´t(It, s)) : Ï• to the world v.
Acceptance: If (At, Q) : Ï• occurs at u and Q contains an accepting state of At,
then we add Ï• to u.
The formal semantics of automaton-labelled formulae are deï¬ned as fol-
lows. Let Îµ be the empty word and deï¬ne Î´t(Q, Îµ) = Q and Î´t(Q, s1 . . . sk) =Î´t(Î´t(Q, s1), s2 . . . sk). If M is a Kripke model, w is a world of M , and At =
MOD, Qt, It, Î´t, Ft is an automaton, then M, w |= (At, Q) : Ï• iï¬€ there ex-
ist worlds w0, . . . , wk = w (of M ) and indices s1, . . . , sk âˆˆ MOD such thatM, w0 |= [t]Ï•, Rs (w
i
iâˆ’1, wi) holds for 1 â‰¤ i â‰¤ k, and Î´t(It, s1 . . . sk) = Q.
Pictorially: M, w |= (At, Q) : Ï• iï¬€
w
s1
s2
sk
0
// w1
// Â· Â· Â·
wkâˆ’1
// wk = w
[t]Ï•
Î´(It, s1)
Â· Â· Â·
Î´(It, s1 . . . skâˆ’1)
Î´(It, s1 . . . sk) = Q
We can see the soundness of these deï¬nitions by the following inter-derivable
sequence of validities of multimodal tense logic which use the residuation prop-erties of s âˆ’1 and [s] shown at right where s âˆ’1 is the converse of s :
[t]Ï• âŠƒ [s1][s2] . . . [sk]Ï•
s âˆ’1
1
[t]Ï• âŠƒ [s2] . . . [sk]Ï•
Ï• âŠƒ [s]Ïˆ
. . .
s âˆ’1Ï• âŠƒ Ïˆ
s âˆ’1
âˆ’1
k
. . . s1
[t]Ï• âŠƒ Ï•
That is, if we want to ensure that [t]Ï• âŠƒ [s1][s2] . . . [sk]Ï• is valid, then it
suï¬ƒces to ensure that s âˆ’1
âˆ’1
k
. . . s1
[t]Ï• âŠƒ Ï• is valid instead. But converse
modalities are not part of our oï¬ƒcial language so we use the occurrence of [t]Ï•at w0 to start an automaton At which tracks the following constraint: Ï• mustbe true at any world w reachable from w0 by the path/word s1 . . . sk.
Our automaton-labelled formulae are similar to formulae of automaton
propositional dynamic logic (APDL) [10]. A formula involving automata inAPDL is of the form [A]Ï•, where A is a ï¬nite automata with one initial state
5and one accepting state. An automaton labelled formula like our (At, Q) : Ï• withQ = {q1, q2, . . . , qk} can be simulated by the APDL formula [B1]Ï• âˆ¨ . . . âˆ¨ [Bk]Ï•where each Bi is the automaton At restricted to start at the initial state qi. Thusour formulation uses a more compact representation in which APDL formulaethat diï¬€er only in their initial state are grouped together. Moreover, we do nottreat diï¬€erent â€œstatesâ€ of an automaton as diï¬€erent automata. Our compactrepresentation not only saves memory but also increases eï¬ƒciency of deduction.
From now on, by a formula we mean either a formula in the primitive lan-
guage (as deï¬ned in Section 2.1) or an automaton-labelled formula.
2.4
Deï¬nitions for Tableau Calculi
As in our previous works on tableau calculi [9, 17], our tableau formulation tracetheir roots to Hintikka via [18]. A tableau rule Ïƒ consists of a numerator Nabove the line and a (ï¬nite) list of denominators D1, D2, . . . , Dk (below theline) separated by vertical bars. The numerator is a ï¬nite formula set, and so iseach denominator. As we shall see later, each rule is read downwards as â€œif thenumerator is L-satisï¬able, then so is one of the denominatorsâ€. The numerator ofeach tableau rule contains one or more distinguished formulae called the principalformulae. A tableau calculus CL for a logic L is a ï¬nite set of tableau rules.
A CL-tableau for X is a tree with root X whose nodes carry ï¬nite formula
sets obtained from their parent nodes by instantiating a tableau rule with theproviso that if a child s carries a set Z and Z has already appeared on the branchfrom the root to s then s is an end node.
Let âˆ† be a set of tableau rules. We say that Y is obtainable from X by
applications of rules from âˆ† if there exists a tableau for X which uses only rulesfrom âˆ† and has a node that carries Y . A branch in a tableau is closed if its endnode carries only âŠ¥. A tableau is closed if every one of its branches is closed. Atableau is open if it is not closed. A ï¬nite formula set X in the primitive languageis said to be CL-consistent if every CL-tableau for X is open. If there is a closedCL-tableau for X then we say that X is CL-inconsistent.
A tableau calculus CL is sound if for all ï¬nite formula sets X in the primitive
language, X is L-satisï¬able implies X is CL-consistent. It is complete if for allï¬nite formula sets X in the primitive language, X is CL-consistent implies Xis L-satisï¬able. Let Ïƒ be a rule of CL. We say that Ïƒ is sound w.r.t. L if forevery instance Ïƒ of Ïƒ, if the numerator of Ïƒ is L-satisï¬able then so is one ofthe denominators of Ïƒ . Any CL containing only rules sound w.r.t. L is sound.
3
A Tableau Calculus for Regular Grammar Logics
Fix a regular grammar logic L and let {At = MOD, Qt, It, Î´t, Ft | t âˆˆ MOD}be the automata specifying L. Recall that formulae are in negation normal form.We use X for a formula set, and semicolon to separate elements of a formulaset. We have deliberately used â€œs.t.â€ for â€œsuch thatâ€ in the set notation of the
6X; p; Â¬p
X; Ï• âˆ§ Ïˆ
X; Ï• âˆ¨ Ïˆ
(âŠ¥)
âŠ¥
(âˆ§)
(âˆ¨)
X; Ï•; Ïˆ
X; Ï• | X; Ïˆ
X; [t]Ï•
X; (A
(label)
(add)
t, Q): Ï•
if Q âˆ© F
X; (A
t = âˆ…
t , It): Ï•
X; (At, Q): Ï•; Ï•
X; t Ï•
(trans) {(As, Î´s(Q,t)):Ïˆ s.t. (As, Q):Ïˆ âˆˆ X}; Ï•
Fig. 1. Tableau Rules
denominator of the (trans)-rule because we use colon in automaton-labelled for-mulae and the alternative | indicates a branching rule! The tableau calculus CLis given in Figure 1. The ï¬rst ï¬ve rules are static rules, and the last rule is atransitional rule. An example is in the appendix.
A tableau calculus CL has the analytic superformula property iï¬€ to every
ï¬nite set X we can assign a ï¬nite set Xâˆ— which contains all formulae that may
CL
appear in any tableau for X. We write Sf (Ï•) for the set of all subformulae of Ï•,and Sf (X) for the set
Sf (Ï•)âˆª{âŠ¥}. Our calculus has the analytic superfor-
Ï•âˆˆX
mula property, with Xâˆ— = Sf (X) âˆª {(A
CL
t, Q): Ï• s.t. [t]Ï• âˆˆ Sf (X ) and Q âŠ† Qt}.
Lemma 2. The tableau calculus CL is sound.
Proof. We show that CL contains only rules sound w.r.t. L as follows. Supposethat the numerator of the considered rule is satisï¬ed at a world w in a modelM = W, Ï„, {Rt | t âˆˆ MOD}, h . We have to show that at least one of thedenominators of the rule is also satisï¬able. For the static rules, we show thatsome denominator is satisï¬ed at w itself. For the transitional rule (trans), weshow that its denominator is satisï¬ed at some world reachable from w via Rt.
(âŠ¥), (âˆ§), (âˆ¨): These cases are obvious.(label): If M, w |= X; [t]Ï• then M, w |= (At, It): Ï• by deï¬nition.(add): Suppose that M, w |= X; (At, Q): Ï• and Q âˆ© Ft = âˆ…. By deï¬nition, there
exist worlds w0, . . . , wkâˆ’1, wk = w and indices s1, . . . , sk âˆˆ MOD such thatM, w0 |= [t]Ï•, and Rs (w
i
iâˆ’1, wi) holds for 1 â‰¤ i â‰¤ k, and Î´t(It, s1 . . . sk ) = Q.
Since Q âˆ© Ft = âˆ…, the word s1 . . . sk is accepted by At. By Lemma 1, itfollows that M, w0 |= [s1] . . . [sk]Ï•. Since w = wk and Rs (w
i
iâˆ’1 , wi) holds
for 1 â‰¤ i â‰¤ k, we must have M, w |= Ï•.
(trans): Suppose that M, w |= X; t Ï•. Then there exists some u such that
Rt(w, u) holds and M, u |= Ï•. For each (As, Q): Ïˆ âˆˆ X, we have M, w |=(As, Q): Ïˆ, and by the semantics of automaton-labelled formulae, it followsthat M, u |= (As, Î´s(Q, t)): Ïˆ. Hence, the denominator is satisï¬ed at u.
4
Completeness
We prove completeness of our calculus via model graphs following [18, 9, 16, 17]by giving an algorithm that accepts a ï¬nite CL-consistent formula set X in theprimitive language and constructs an L-model graph (deï¬ned in Section 4.2) forX that satisï¬es every one of its formulae at the appropriate world.
74.1
Saturation
In the rules (âˆ§), (âˆ¨), (label) the principal formula does not occur in the denomi-nators. For any of these rules Î´, let Î´ denote the rule obtained from Î´ by addingthe principal formula to each of the denominators. Let SCL denote the set ofstatic rules of CL with (âˆ§), (âˆ¨), (label) replaced by (âˆ§ ), (âˆ¨ ), (label ). For everyrule of SCL, except (âŠ¥), the numerator is included in each of the denominators.
For a ï¬nite CL-consistent formula set X, a formula set Y is called a CL-
saturation of X if Y is a maximal CL-consistent set obtainable from X by ap-plications of the rules of SCL. A set X is closed w.r.t. a tableau rule if applyingthat rule to X gives back X as one of the denominators.
Lemma 3. Let X be a ï¬nite CL-consistent formula set and Y a CL-saturationof X. Then X âŠ† Y âŠ† Xâˆ—
C
and Y is closed w.r.t. the rules of SCL. Furthermore,
L
there is an eï¬€ective procedure that, given a ï¬nite CL-consistent formula set X,constructs some CL-saturation of X.
Proof. It is clear that X âŠ† Y âŠ† Xâˆ— . Observe that if a rule of SCL is ap-
CL
plicable to Y , then one of the corresponding instances of the denominators isCL-consistent. Since Y is a CL-saturation, Y is closed w.r.t. the rules of SCL.
We construct a CL-saturation of X as follows: let Y = X; while there is some
rule Î´ of SCL applicable to Y such that one of its corresponding denominatorinstance Z is CL-consistent and strictly contains Y , set Y = Z. At each iteration,Y âŠ‚ Z âŠ† Xâˆ— . Hence the above process always terminates. It is clear that the
CL
resulting set Y is a CL-saturation of X.
4.2
Proving Completeness via Model Graphs
A model graph is an L-model graph if its frame is an L-frame. An L-model graph
W, Ï„, {Rt | t âˆˆ MOD}, H is saturated if every w âˆˆ W satisï¬es:
And: if Ï• âˆ§ Ïˆ âˆˆ H(w) then {Ï•, Ïˆ} âŠ† H(w);Or: if Ï• âˆ¨ Ïˆ âˆˆ H(w) then Ï• âˆˆ H(w) or Ïˆ âˆˆ H(w);Box: if [t]Ï• âˆˆ H(w) and Rt(w, u) holds then Ï• âˆˆ H(u);Dia: if t Ï• âˆˆ H(w) then there exists a u âˆˆ W such that Rt(w, u) and Ï• âˆˆ H(u).
A saturated model graph is consistent if no world contains âŠ¥, and no world
contains {p, Â¬p}. Our model graphs merely denote a data structure, while Raut-enbergâ€™s model graphs are required to be saturated and consistent.
Lemma 4. If M = W, Ï„, {Rt | t âˆˆ MOD}, H is a consistent saturated L-modelgraph, then M satisï¬es all formulae of H(Ï„ ) which are in the primitive language.
Proof. By proving Ï• âˆˆ H(w) implies M, w |= Ï• by induction on the length of Ï•.
Given a ï¬nite CL-consistent set X in the primitive language, we construct a
consistent saturated L-model graph M = W, Ï„, {Rt | t âˆˆ MOD}, H such thatX âŠ† H(Ï„ ), thereby giving an L-model for X.
84.3
Constructing Model Graphs
In the following algorithm, the worlds of the constructed model graph are markedeither as unresolved or as resolved.
Algorithm 1
Input: a ï¬nite CL-consistent set X of formulae in the primitive language.
Output: an L-model graph M = W, Ï„, {Rt | t âˆˆ MOD}, H satisfying X.
1. Let W = {Ï„ }, H(Ï„ ) be a CL-saturation of X, and Rt = âˆ… for all t âˆˆ MOD.
Mark Ï„ as unresolved.
2. While there are unresolved worlds, take one, say w, and do the following:
(a) For every formula t Ï• in H(w):
i. Let Y = {(As, Î´s(Q, t)): Ïˆ s.t. (As, Q): Ïˆ âˆˆ H(w)} âˆª {Ï•} be the result
of applying rule (trans) to H(w), and let Z be a CL-saturation of Y .
ii. If âˆƒu âˆˆ W on the path from the root to w with H(u) = Z, then add
the pair (w, u) to R . Otherwise, add a new world w
t
Ï• with content Z
to W , mark it as unresolved, and add the pair (w, wÏ•) to R .
t
(b) Mark w as resolved.
3. Let Rt be the least extension of R for t âˆˆ MOD such that W, Ï„, {R
t
t | t âˆˆ
MOD} is an L-frame.
This algorithm always terminates: eventually, for every w, either w contains
no t -formulae, or there exists an ancestor with H(u) = Z at Step 2(a)ii becauseall CL-saturated sets are drawn from the ï¬nite and ï¬xed set Xâˆ— .
CL
Lemma 5. Suppose Rt(w, u) holds via Step 3. Then there exist w0, . . . , wk inM with w0 = w, wk = u, and indices s1, . . . , sk âˆˆ MOD such that Rs (wiâˆ’1, wi)
i
holds for 1 â‰¤ i â‰¤ k, and Rs â—¦. . .â—¦R
âŠ† R
1
sk
t follows from the L-frame restrictions.
Proof. By induction on number of inferences in deriving Rt(w, u) when extendingR
â—¦
âŠ†
s to Rs for s âˆˆ MOD, with L-frame restrictions of the form Rt
. . .â—¦R
R
1
th
s.
4.4
Completeness Proof
Lemma 6. Let X be a ï¬nite CL-consistent set of formulae in the primitive lan-guage and M = W, Ï„, {Rt | t âˆˆ MOD}, H be the model graph for X constructedby Algorithm 1. Then M is a consistent saturated L-model graph satisfying X.
Proof. It is clear that M is an L-model graph and for any w âˆˆ W , the set H(w) isCL-consistent. We want to show that M is a saturated model graph. It suï¬ƒces toshow that, for every w, u âˆˆ W , if [t]Ï• âˆˆ H(w) and Rt(w, u) holds then Ï• âˆˆ H(u).Suppose that [t]Ï• âˆˆ H(w) and Rt(w, u) holds. By Lemma 5, there exist worldsw0, . . . , wk with w0 = w, wk = u and indices s1, . . . , sk âˆˆ MOD such thatR
â—¦
âŠ†
s (wiâˆ’1, wi) holds for 1 â‰¤ i â‰¤ k and Rs
. . . â—¦ Rs
Rt is a consequence of the
i
1
k
L-frame restrictions. Since H(w) is a CL-saturation, we have that (At, It): Ï• âˆˆH(w). By Step 2a of Algorithm 1, (At, Î´t(It, s1 . . . si)): Ï• âˆˆ H(wi) for 1 â‰¤ i â‰¤ k.Thus (At, Î´t(It, s1 . . . sk)): Ï• âˆˆ H(u). Since Rs â—¦. . .â—¦R
âŠ† R
1
sk
t is a consequence of
the L-frame restrictions, by Lemma 1, the word s1 . . . sk is accepted by At. HenceÎ´t(It, s1 . . . sk) âˆ© Ft = âˆ…. It follows that Ï• âˆˆ H(u), since H(u) is a CL-saturation.
9The following theorem follows from Lemmas 2 and 6.
Theorem 1. The tableau calculus CL is sound and complete.
5
Complexity
The satisï¬ability problem of a logic L is to check the L-satisï¬ability of an inputformula Ï•. The general satisï¬ability problem of a class C of logics is to checkL-satisï¬ability of an input formula Ï• in an input logic L âˆˆ C.
Demri [4] proved that the general satisï¬ability problem of regular grammar
logics is EXPTIME-complete by a transformation into satisï¬ability for PDL. Wenow obtain the upper bound EXPTIME using our tableaux calculus.
We need a rule (âˆª) to coalesce (At, Q): Ï• and (At, Q ): Ï• into (At, Q âˆª Q ): Ï•
X ; (A
(âˆª)
t, Q): Ï• ; (At, Q ): Ï•
X ; (At, Q âˆª Q ): Ï•
Observe that X; (At, Q): Ï•; (At, Q ): Ï• is CL-consistent iï¬€ X; (At, Q âˆª Q ): Ï• isCL-consistent. This follows from the facts that Î´t(Q, s) âˆª Î´t(Q , s) = Î´t(Q âˆª Q , s)and ((Q âˆ© Ft = âˆ…) âˆ¨ (Q âˆ© Ft = âˆ…)) â‰¡ ((Q âˆª Q ) âˆ© Ft = âˆ…). Thus, rule (âˆª) canbe added to CL as a static rule, and used whenever possible without aï¬€ectingsoundness and completeness. Let CLu be CL plus (âˆª).
Allowing (âˆª) requires a change in the semantics of automaton-labelled formu-
lae to: if M is a Kripke model, w is a world of M , and At = MOD, Qt, It, Î´t, Ftis an automaton, then M, w |= (At, Q) : Ï• iï¬€ for every q âˆˆ Q there existworlds w0, . . . , wkâˆ’1, wk = w (of M ) and indices s1, . . . , sk âˆˆ MOD such thatM, w0 |= [t]Ï•, and Rs (w
i
iâˆ’1, wi) holds for 1 â‰¤ i â‰¤ k, and q âˆˆ Î´t(It, s1 . . . sk ) âŠ† Q.
Let L be a regular logic and X a ï¬nite formula set in the primitive language.
Let n be the sum of the sizes of the formulae in X and the sizes of the automataspecifying L. To check whether X is L-satisï¬able we can search for a closedCLu-tableau for X, or equivalently, examine an and-or tree for X constructedby using Algorithm 1 to apply our CLu-tableau rules in a systematic way. In sucha tree, and-branching is caused by all possible applications of rule (trans), whileor-branching is caused by an application of rule (âˆ¨). The other CLu-tableaurules, including (âˆª), are applied locally for each node whenever possible.
There are at most O(n) unlabelled subformulae of X, and at most 2O(n)
diï¬€erent labels. By using the rule (âˆª) whenever possible, each subformula of Xoccurs in a node with at most two labels, so a node contains at most 2n i.e. O(n)labelled formulae. Hence there are at most (2O(n))O(n) = 2O(n2) diï¬€erent nodes.Without the rule (âˆª), there are at most 22O(n) diï¬€erent nodes, which breaksEXPTIME worst-case complexity, so the (âˆª) rule is absolutely essential. But itis not necessary for the satisï¬ability problem of a ï¬xed logic.
Algorithm 1 terminates in general because it checks for repeated ancestors:
this check is built into the deï¬nition of an end-node, and also in Step 2(a)ii. Thusthe same node can appear on multiple branches. In the worst case, Algorithm 1therefore requires 22O(n2) time. We therefore reï¬ne it into Algorithm 2 below:
10Algorithm 2
Input: a ï¬nite set X of formulae in the primitive language.
Output: a ï¬nite graph G = (V, E)
1. Let G =&lt; V, E &gt;=&lt; {X}, âˆ… &gt;, and mark X as unresolved.2. While V contains unresolved nodes, take one, say n, and do:
(a) If (âˆª) is applicable to n then apply it to obtain denominator d1
(b) Else if any static rule of CL is applicable to n then apply it to obtain
denominator(s) d1 (and possibly d2)
(c) Else, for every formula t Ï•i in n, let di = {(As, Î´s(Q, t)): Ïˆi s.t. (As, Q):
Ïˆi âˆˆ n} âˆª {Ï•i} be the denominator obtained by applying (trans) to n
(d) Mark n as resolved (n is an or/and node if the applied rule is/isnâ€™t (âˆ¨))
(e) For every denominator d = d1, Â· Â· Â· , dk:
i. If some proxy c âˆˆ V has c = d, then add the edge (n, c) to E
ii. Else add d to V , add (n, d) to E, and mark d as unresolved.
Algorithm 2 builds an and-or graph G monotonically by â€œcachingâ€ previously
seen nodes (but not their open/closed status). The graph G contains a node dfor every applicable static rule denominator, not just their CL-saturation as inAlgorithm 1. Each node appears only once because repetitions are representedby â€œcross-treeâ€ edges to their ï¬rst occurrence, so G has at most 2O(n2) nodes.
We now make passes of the and-or graph G, marking nodes as false in a
monotonic way. In the ï¬rst pass we mark the node containing âŠ¥, if it exists, sincefalse captures inconsistency. In each subsequent pass we mark any unmarked or-node with two false-marked children, and mark any unmarked and-node with atleast one false-marked child. We stop making passes when some pass marks nonode. Otherwise, we must terminate after 2O(n2) passes since the root must thenbe marked with false. Note that once a node is marked with false this mark isnever erased. Finally, mark all non-false nodes with true giving graph Gf .
Lemma 7. If node n âˆˆ Gf is marked false then n is CLu-inconsistent.
Proof. By induction on the number of passes needed to mark n with false.
Lemma 8. If a node n âˆˆ Gf is marked true then it is CLu-consistent.
Proof. An easy proof is to take the sub-graph Gn generated by n; replace eachsequence of true-marked static rule denominators by one true-marked node con-taining their union, which represents their CLu-saturation; and turn the resultingsub-graph into an L-frame by appropriately extending it as in Step 3 of Algo-rithm 1. For each node x, putting p âˆˆ h(x) iï¬€ p âˆˆ x gives an L-model for n since:all eventualities in a true-marked node are fulï¬lled by its children, and these areguaranteed to be marked true; and each true-marked or-node has at least onetrue-marked child. By the completeness of CLu, every CLu-tableau for n mustbe open. A slightly trickier proof converts Gn into an and-or tree by mimickingthe rule applications from Gn but unwinding edges to non-ancestor-proxies bymaking a copy of the proxy. This reproduces all CLu-tableaux for n constructibleby Algorithm 1 (sic) and each one is open by its construction.
Algorithm 2 and the creation of Gf runs in time (2O(n2))2 = 22.O(n2) and so
the general satisï¬ability problem of regular grammar logics is in EXPTIME.
11(IâŠ¥) Z
Z ; p; Â¬p
(IâŠ¥) Z; p p Z ; Â¬p
Î¶
Î¶ âˆ§ Î¾
Z
Z ; Ï• âˆ§ Ïˆ
Z
Z ; Ï• âˆ¨ Ïˆ
(Iâˆ§)
(Iâˆ¨)
Î¶
Î¶
Î¾
Z
Z ; Ï•; Ïˆ
Z
Z ; Ï• | Z
Z ; Ïˆ
Î¶
Î¶
Z
Z ; [t]Ï•
Z
Z ; (At, Q): Ï•
(Ilabel)
(Iadd)
if Q âˆ© F
Î¶
Î¶
t = âˆ…
Z
Z ; (At, It): Ï•
Z
Z ; (At, Q): Ï•; Ï•
[t]Î¶
Z
Z ; t Ï•
(Itrans)
Î¶
{(As, Î´s(Q, t)): Ïˆ s.t. (As, Q): Ïˆ âˆˆ Z} {(As, Î´s(Q, t)): Ïˆ s.t. (As, Q): Ïˆ âˆˆ Z }; Ï•
Fig. 2. Rules of the Calculus for Interpolation
6
Eï¬€ective Interpolation
We say that Î¶ is an interpolation formula in L for the formula Ï• âŠƒ Ïˆ if allprimitive propositions of Î¶ are common to Ï• and Ïˆ, and Ï• âŠƒ Î¶ and Î¶ âŠƒ Ïˆ areboth L-valid. The Craig interpolation lemma for L states that if Ï• âŠƒ Ïˆ is L-valid,then there exists an interpolation formula in L for Ï• âŠƒ Ïˆ. This lemma is eï¬€ectiveif the proof of the lemma actually constructs the interpolation formula.
Assume our language contains
with the usual semantics. We prove eï¬€ective
Craig interpolation for all regular grammar logics using the method of [16].
Our tableau calculi are refutation calculi, so we use an indirect formulation
of interpolation. Given two sets X and Y of formulae, and using Î¶ to denote thenegation normal form of Â¬Î¶, we say that Î¶ is an interpolation formula w.r.t. CLfor the pair X, Y , and also that X Î¶ Y is CL-valid, if: all primitive propositionsof Î¶ are common to X and Y , the formula Î¶ does not contain automaton-labelledformulae, and the sets X; Î¶ and Î¶; Y are both CL-inconsistent. Since CL is soundand complete, it follows that if Ï• Î¶ Ïˆ is CL-valid, then Ï• âŠƒ Î¶ and Î¶ âŠƒ Ïˆ areboth L-valid, and hence that Î¶ is an interpolation formula in L for Ï• âŠƒ Ïˆ.
We now show that for any ï¬nite formula sets X and Y , if X; Y is CL-
inconsistent, then there exists an interpolation formula w.r.t. CL for the pair
X, Y . It follows that the Craig interpolation lemma holds for L.
Observe that Y Ï• X is CL-valid iï¬€ X Ï• Y is CL-valid. We call Y Ï• X the
reverse form of X Ï• Y .
The rule (IÎ´) below left is an interpolation rule if the inference step below
right is an instance of the tableau rule with name (Î´):
N Ï• N
N ; N
(IÎ´) D Ï•1
Ï•k
1
D |
|
1
. . . | Dk
D
D
. . . | D
k
1; D1
k; Dk
Provided that (Î´) is a CL-tableau rule, the interpolation rule (IÎ´) is CL-sound ifCL-validity of all D
Ï•1
Ï•k
1
D1, . . . , Dk
D implies CL-validity of N Ï• N .
k
12Figure 2 contains the interpolation rules obtained from the tableau rules for
regular grammar logics. Each tableau rule of CL except (IâŠ¥) has one corre-sponding interpolation rule. Rule (âŠ¥) has an interpolation rule for each of itstwo principal formulae but these rules have no denominator because it is notnecessary. Rule (âˆª) has no interpolation rule since it is just an optimisation rule.
Lemma 9. The above interpolation rules are CL-sound.
Proof. We consider (Itrans) only, the others are similar. Let X = {(As, Î´s(Q, t)):Ïˆ s.t. (As, Q): Ïˆ âˆˆ Z} and Y = {(As, Î´s(Q, t)): Ïˆ s.t. (As, Q): Ïˆ âˆˆ Z }. Supposethat X Î¶ Y ; Ï• is CL-valid. Thus, both X; Î¶ and Î¶; Y ; Ï• are CL-inconsistent,and have closed CL-tableaux. We show that Z [t]Î¶ Z ; t Ï• is CL-valid by givingclosed CL-tableaux for both Z; t Î¶ and [t]Î¶; Z ; t Ï•:
[t]Î¶; Z ; t Ï•
(label)
(At, It): Î¶; Z ; t Ï•
(trans)
(At, Î´t(It, t)): Î¶; Y ; Ï•
(add)
Z; t Î¶
(A
(
t, Î´t(It, t)): Î¶ ; Î¶ ; Y ; Ï•
trans)
(wk)
X; Î¶
Î¶; Y ; Ï•
(assumption)
(assumption)
âŠ¥
âŠ¥
Applying (add) above right is justiï¬ed because Î´t(It, t) âˆ© Ft = âˆ… since At
accepts word t. Also, the rule (wk) of weakening is obviously admissible.
These rules build the numeratorâ€™s interpolant from those of the denominators.
Using Lemma 9, and the technique of [16, Lemmas 13 and 14] we obtain:
Theorem 2. Regular grammar logics enjoy eï¬€ective Craig interpolation.
7
Further Work and Conclusions
Our main contribution is a tableau calculus that forms a decision procedurefor the whole class of regular grammar logics. Our automaton-labelled formulaeare similar to formulae of APDL [10], but with a more compact representationusing sets of states instead of single states. We have shown that automaton-labelled formulae work well with the traditional techniques of proving soundnessand completeness. Our calculus gives a simple estimate of the upper complexitybound of regular grammar logics, and can be used to obtain eï¬€ective Craiginterpolation for these logics. We have since found that Craig interpolation forregular grammar logics follows from [13, Corollary B4.1] and [12].
The preï¬xed tableaux of Baldoni et al. give a decision procedure only for
right linear logics. A preï¬xed calculus that simulates our calculus would be lesseï¬ƒcient because it would repeatedly search the current branch for computation,not just for loops as in our case. Moreover, it is well-known that loop checkingcan be done eï¬ƒciently using, e.g., a hash table. Finally, the transformation of
13Demri and de Nivelle into GF2 is based on states, but not sets of states, whichreduces eï¬ƒciency. Also their resulting formula sets are much larger because theykeep a copy of the formulae deï¬ning an automaton At for each formula [t]Ï•,whereas we can keep only t and Q for (At, Q) in (At, Q): Ï•. Similar observationshave been stated for formulae of APDL.
By propagating false â€œon the ï¬‚yâ€, we believe we can prove global caching
sound for checking satisï¬ability in multimodal K with global assumptions i.e.â€œchecking ALC-satisï¬ability of a concept w.r.t. a TBox with general axiomsâ€ [6].
References
1. F. Baader and U. Sattler. An overview of tableau algorithms for description logics.
Studia Logica, 69:5â€“40, 2001.
2. M. Baldoni. Normal Multimodal Logics: Automatic Deduction and Logic Program-
ming Extension. PhD thesis, Dip. di Inf., Univ. degli Studi di Torino, Italy, 1998.
3. M. Baldoni, L. Giordano, and A. Martelli. A tableau for multimodal logics and
some (un)decidability results. In TABLEAUXâ€™1998, LNCS 1397:44-59, 1998.
4. S. Demri. The complexity of regularity in grammar logics and related modal logics.
Journal of Logic and Computation, 11(6):933â€“960, 2001 (see also the long version).
5. S. Demri and H. de Nivelle. Deciding regular grammar logics with converse through
ï¬rst-order logic. Journal of Logic, Language and Information, 2005. To appear.
6. F Donini and F Massacci. EXPTIME tableaux for ALC. Artiï¬cial Intelligence,
124:87â€“138, 2000.
7. R Fagin, J Y Halpern, Y Moses, and M Y Vardi. Reasoning About Knowledge.
MIT Press, 1995.
8. L. FariËœ
nas del Cerro and M. Penttonen. Grammar logics. Logique et Analyse,
121-122:123â€“134, 1988.
9. R. GorÂ´e. Tableau methods for modal and temporal logics. In Dâ€™Agostino et al,
editor, Handbook of Tableau Methods, pages 297â€“396. Kluwer, 1999.
10. D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic. MIT Press, 2000.11. I. Horrocks and U. Sattler. Decidability of SHIQ with complex role inclusion
axioms. Artiï¬cial Intelligence, 160(1-2):79â€“104, 2004.
12. M. Kracht. Reducing modal consequence relations. JLC, 11(6):879â€“907, 2001.13. M. Marx and Y. Venema. Multi-dimensional Modal Logic. Kluwer, 1997.14. A. Mateescu and A. Salomaa. Formal languages: an introduction and a synopsis.
In Handbook of Formal Languages - Volume 1, pages 1â€“40. Springer, 1997.
15. J.-J.Ch. Meyer and W. van der Hoek. Epistemic Logic for Computer Science and
Artiï¬cial Intelligence. Cambridge University Press, 1995.
16. L.A. Nguyen. Analytic tableau systems and interpolation for the modal logics
KB, KDB, K5, KD5. Studia Logica, 69(1):41â€“57, 2001.
17. L.A. Nguyen. Analytic tableau systems for propositional bimodal logics of knowl-
edge and belief. In TABLEAUX 2002, LNAI 2381:206-220. Springer, 2002.
18. W. Rautenberg. Modal tableau calculi and interpolation. JPL, 12:403â€“423, 1983.19. J. van Benthem. Correspondence theory. In D. Gabbay and F. Guenthner, editors,
Handbook of Philosophical Logic, Vol II, pages 167â€“247. Reidel, Dordrecht, 1984.
20. M. Wessel. Obstacles on the way to qualitative spatial reasoning with description
logics: Some undecidability results. In Description Logics 2001.
14Appendix: an example
Example 2. Let MOD = {0, 1, 2}. Consider the grammar logic L with the in-clusion axioms [0]Ï• âŠƒ Ï• and [i]Ï• âŠƒ [j][k]Ï• if i = (j + k) mod 3. This is aregular grammar logic because the corresponding grammar is regular. We haveAi = MOD, MOD, {0}, Î´, {i} for i âˆˆ MOD, where Î´ = {(j, k, l) | j, k, l âˆˆ{0, 1, 2} and l = (j + k) mod 3}.
We give a closed CL-tableau for X = { 0 p, [0](Â¬pâˆ¨ 1 q), [1](Â¬qâˆ¨ 2 r), [0]Â¬r},
in which principal formulae of nodes are underlined. The arrows stand for ruleapplications and are annotated with the rule name. The labels Ri for i âˆˆ {0, 1, 2}to the right of the arrows marked with (trans)-rule applications stand for the labelon the associated edges in the underlying model being explored by the tableau.
0 p; [0](Â¬p âˆ¨ 1 q); [1](Â¬q âˆ¨ 2 r); [0]Â¬r
3 x (label)

0 p; (A0, {0}): (Â¬p âˆ¨ 1 q); (A1, {0}): (Â¬q âˆ¨ 2 r); (A0, {0}): Â¬r
(trans)
R0

p; (A0, {0}): (Â¬p âˆ¨ 1 q); (A1, {0}): (Â¬q âˆ¨ 2 r); (A0, {0}): Â¬r
(add)

p; (A0, {0}): (Â¬p âˆ¨ 1 q); Â¬p âˆ¨ 1 q; (A1, {0}): (Â¬q âˆ¨ 2 r); (A0, {0}): Â¬r
f
f
f
f
(âˆ¨)
f
f
f
f
f
f
f
f
f
(âˆ¨)
f
f
f
f
f
f
f
f
f

f
f

ssf
p; Â¬p; . . .
p;
1 q; (A0, {0}): (Â¬p âˆ¨ 1 q); (A1, {0}): (Â¬q âˆ¨ 2 r); (A0, {0}): Â¬r
(âŠ¥)
(trans)
R1


âŠ¥
q; (A0, {1}): (Â¬p âˆ¨ 1 q); (A1, {1}): (Â¬q âˆ¨ 2 r); (A0, {1}): Â¬r
(add)

q; (A0, {1}): (Â¬p âˆ¨ 1 q); (A1, {1}): (Â¬q âˆ¨ 2 r); Â¬q âˆ¨ 2 r; (A0, {1}): Â¬r
f
f
f
f
(âˆ¨)
f
f
f
f
f
f
f
f
(âˆ¨)
f
f
f
f
f
f
f
f
ss
f

f

f
f
f
q; Â¬q; . . .
q;
2 r; (A0, {1}): (Â¬p âˆ¨ 1 q); (A1, {1}): (Â¬q âˆ¨ 2 r); (A0, {1}): Â¬r
(âŠ¥)
(trans)
R2


âŠ¥
r; (A0, {0}): (Â¬p âˆ¨ 1 q); (A1, {0}): (Â¬q âˆ¨ 2 r); (A0, {0}): Â¬r
(add)

r; (A0, {0}): (Â¬p âˆ¨ 1 q); (A1, {0}): (Â¬q âˆ¨ 2 r); (A0, {0}): Â¬r; Â¬r
(âŠ¥)

âŠ¥
15
