##########################################################################
# IF THIS FILE IS CALLED "Jamrules", THEN IT WAS GENERATED BY configure. #
# IN THIS CASE, PLEASE DO NOT EDIT, EDIT Jamrules.in INSTEAD!            #
##########################################################################

include $(TOP)/Jamimport ;

noaspell = 1 ;
noeditline = 1 ;
notesseract =  ;
nosdl = 1 ;
nolept = 1 ;
nolua =  ;
nofst = 1 ;
noposix =  ;

prefix = /usr/local ;
# autoconf incorrectly uses ${...} syntax, which Jam doesn't understand
# this is a temporary workaround until we have figured out a better way
# to fix this
datarootdir = $(prefix)/share ;
datadir = $(prefix)/share ;

INSTALL_DIR = $(prefix)/bin ;
OCRODATA = $(datadir)/ocropus ;
OCROSCRIPTS = $(datadir)/ocropus/scripts ;

C++ = g++ -g -O2 -Wall -Wno-sign-compare $(defs) ; # -Wuninitialized -Wwrite-strings 
if $(opt) != "" {
OPTIM = $(opt) ;
} else {
# do NOT compile with -DUNSAFE during development
# do NOT enable -DUNSAFE globally, except to detect high overhead error checking
OPTIM = -g -O2 ;
}
ldflags =  -lpthread -ltesseract_full -lpthread -ltiff -ljpeg -lpng -lz  ;
LINK = g++ $(ldflags) ;

TESSHEADERS = /usr/local/include/tesseract ;
TESSLIBS = /usr/local/lib ;

# This is a simple hack to make environment variables affect the build.
# When invoked on, say, SDL, it will add SDL_LIBDIR to -L and SDL_INCDIR to -I.
rule ConfigurePaths {
    LINKLIBS += -L$($(1)_LIBDIR) ;
    C++FLAGS += -I$($(1)_INCDIR) ; 
}

ConfigurePaths LEPTONICA OPENFST SDL SDL_IMAGE SDL_GFX ;

LINKLIBS += -L$(TESSLIBS) ;

ALWAYS unittest ;
rule RunOn {
    Depends $(<) : $(>) ;
}

rule Lib {
    STATIC_LIBS = $(1) $(STATIC_LIBS) ;
    Library $(1) : $(2) ;
}

rule Exe {
    for I in $(1) {
        if $(2) {
            Main $(I) : $(2) ;
        } else {
            Main $(I) : $(I).cc ;
        }
        LinkLibraries $(I) : $(STATIC_LIBS) ;
    }
}

rule AddC++Flags {
    C++FLAGS on <$(SOURCE_GRIST)>$(1)$(SUFOBJ) += $(2) ;
}

rule AddDynamicLib {
    LINKLIBS += -l$(1) ;
}

actions RunOn {
    echo $(>)
    ./$(>)
}
rule UnitTest {
    for I in $(1) {
        Exe $(I) : $(I).cc $(2) ;
    }
    ObjectC++Flags $(1) : -DTEST -fno-inline ;
    RunOn unittest : $(1) ;
}

actions CleanDir {
    rm -f *.o *~ errors.err *.a
    file * | grep '80386.*dynamically linked' | sed 's/:.*//' | xargs rm -v
}

CleanDir distclean ;

ALWAYS errorrates ;
actions compute_error_rates {
    $(TOP)/eval/eval.sh
}

compute_error_rates errorrates ;


actions GenerateVersion {
    cd $(TOP) && ./generate_version_cc.sh $(<)
}

rule DefMain {
    local obj = <$(SOURCE_GRIST)>main-$(<)$(SUFOBJ) ;
    Object $(obj) : $(<).cc ;
    ObjectC++Flags $(obj) : -DMAIN ;
    MainFromObjects $(<) : $(obj) ;
    LinkLibraries $(<) : $(STATIC_LIBS) ;
}

rule UserObject {
    switch $(>) {
        case *.pkg : 
                # C++ on $(<) = g++ -DLUA_CPLUSPLUS ;
                C++ $(<) : $(<:S=.cc) ;
                Tolua $(<:S=.cc) : $(>) ;
                # Clean clean : $(<:S=.cc) ;
        case * : 
                Echo "unknown suffix on" $(>) ;
    }
}

# Usage: LibraryFromCustomObject Library : Object : Source ;
rule LibraryFromCustomObject {
    LibraryFromObjects $(1) : $(2) ;
    local _obj = [ FGristFiles $(2) ] ;
    local _src = [ FGristFiles $(3) ] ;
    Object $(_obj) : $(_src) ;
    Depends obj : $(_obj) ;
}

rule Tolua {
    Depends $(<) : $(>) ;
    RunTolua $(<) : $(>) ;
    MakeLocate $(<) : $(SUBDIR) ;
}

actions RunTolua {
    $(TOP)/ext/tolua++/tolua++ -L $(TOP)/ocroscript/hook_exceptions.lua -o $(<) $(>)
}
